import { resolve } from 'path';
import { readFileIfExists, writeFile } from '../utils/fs.js';
import type { ProjectConfig, AgentTemplate } from '../types/index.js';

export class TemplateEngine {
  private readonly templates = new Map<string, string>();

  constructor() {
    this.initializeDefaultTemplates();
  }

  async generateAgentsFile(config: ProjectConfig, templateType: string): Promise<string> {
    const template = this.templates.get(templateType) || this.templates.get('default')!;
    
    return this.processTemplate(template, {
      PROJECT_NAME: config.name,
      STACK: config.stack.language,
      FRAMEWORK: config.stack.framework || '',
      FRAMEWORK_TEXT: config.stack.framework ? ` with ${config.stack.framework}` : '',
      FRAMEWORK_CONTEXT: config.stack.framework ? ` using ${config.stack.framework}` : '',
      DATE: new Date().toISOString().split('T')[0],
      TEST_FRAMEWORK: config.stack.testFramework || 'jest',
      PACKAGE_MANAGER: config.stack.packageManager || 'npm',
      EXISTING_AGENTS: config.agents.filter(a => a.detected).map(a => a.name).join(', ') || 'none'
    });
  }

  private processTemplate(template: string, variables: Record<string, string>): string {
    let result = template;
    
    // Replace simple variables
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`{{${key}}}`, 'g');
      result = result.replace(regex, value);
    }
    
    // Process conditional blocks - remove all handlebars-style conditionals for now
    result = result.replace(/{{#if[^}]*}}[\s\S]*?{{\/if}}/g, '');
    
    // Clean up extra whitespace and empty lines
    result = result.replace(/\n\s*\n\s*\n/g, '\n\n');
    
    return result;
  }

  private initializeDefaultTemplates(): void {
    this.templates.set('default', this.getDefaultTemplate());
    this.templates.set('web', this.getWebTemplate());
    this.templates.set('cli', this.getCLITemplate());
    this.templates.set('library', this.getLibraryTemplate());
    this.templates.set('fullstack', this.getFullstackTemplate());
    this.templates.set('mobile', this.getMobileTemplate());
  }

  private getDefaultTemplate(): string {
    return `# Agent Configuration for {{PROJECT_NAME}}

**Stack**: {{STACK}}{{FRAMEWORK_TEXT}}
**Generated**: {{DATE}}
**Package Manager**: {{PACKAGE_MANAGER}}
**Existing Agents**: {{EXISTING_AGENTS}}

## Project Context

This is a {{STACK}} project{{FRAMEWORK_CONTEXT}}. The codebase follows modern development practices with automated testing using {{TEST_FRAMEWORK}}.

## Development Guidelines

### Code Quality
- Write clean, maintainable code following {{STACK}} best practices
- Use TypeScript for type safety when applicable
- Follow consistent naming conventions
- Add comments for complex logic

### Testing Strategy
- Write unit tests for all business logic using {{TEST_FRAMEWORK}}
- Aim for high test coverage (>80%)
- Include integration tests for critical paths
- Test edge cases and error scenarios

### Git Workflow
- Use conventional commit messages
- Create meaningful commit messages that explain the "why"
- Keep commits atomic and focused
- Use feature branches for new functionality

## Agent Instructions

### General Behavior
- Always analyze the existing codebase before making changes
- Follow the project's established patterns and conventions
- Ask for clarification when requirements are ambiguous
- Provide clear explanations for design decisions

### Code Changes
- Prefer editing existing files over creating new ones
- Maintain consistency with existing code style
- Add appropriate error handling
- Update tests when modifying functionality

### Security & Best Practices
- Never expose sensitive information in code or logs
- Follow security best practices for {{STACK}}
- Validate all inputs
- Use environment variables for configuration

## Sub-Agents

### Code Reviewer
**Role**: Review code for quality, security, and best practices
**Focus Areas**:
- Code complexity and maintainability
- Security vulnerabilities
- Performance implications
- {{STACK}}-specific best practices

### QA Engineer  
**Role**: Ensure code quality through testing
**Responsibilities**:
- Verify test coverage
- Suggest additional test cases
- Validate error handling
- Check for edge cases

## Stack-Specific Instructions

### {{STACK}} Guidelines
- Use modern syntax and features
- Follow language-specific best practices
- Use {{PACKAGE_MANAGER}} for dependency management
- Implement proper error handling
- Write comprehensive tests

---
*This configuration was generated by AgentInit. Customize as needed for your project.*
`;
  }


  private getWebTemplate(): string {
    return this.getDefaultTemplate() + `

## Web Application Specific Guidelines

### Frontend Development
- Implement responsive design principles
- Optimize for performance and accessibility
- Use semantic HTML elements
- Follow modern CSS practices
- Implement proper state management

### API Integration
- Handle loading and error states
- Implement proper caching strategies
- Use appropriate HTTP methods
- Validate API responses
- Implement retry logic for failed requests

### User Experience
- Provide clear feedback for user actions
- Implement proper form validation
- Use consistent UI patterns
- Optimize for mobile devices
- Consider SEO best practices
`;
  }

  private getCLITemplate(): string {
    return this.getDefaultTemplate() + `

## CLI Tool Specific Guidelines

### Command Design
- Follow Unix philosophy (do one thing well)
- Provide helpful error messages
- Support common flags (--help, --version, --verbose)
- Use consistent command naming
- Implement proper exit codes

### User Interface
- Provide clear usage instructions
- Use colors and formatting appropriately
- Show progress for long-running operations
- Support both interactive and non-interactive modes
- Handle interrupts gracefully

### Configuration
- Support configuration files
- Use environment variables appropriately
- Provide sensible defaults
- Allow command-line overrides
- Document all configuration options
`;
  }

  private getLibraryTemplate(): string {
    return this.getDefaultTemplate() + `

## Library/Package Specific Guidelines

### API Design
- Design intuitive and consistent APIs
- Follow semantic versioning
- Provide comprehensive documentation
- Include usage examples
- Consider backwards compatibility

### Distribution
- Configure proper build process
- Include necessary metadata
- Optimize bundle size
- Support tree shaking
- Provide TypeScript definitions

### Testing
- Test all public APIs
- Include performance tests
- Test in different environments
- Provide testing utilities
- Document testing approaches
`;
  }

  private getFullstackTemplate(): string {
    return this.getDefaultTemplate() + `

## Full Stack Application Guidelines

### Architecture
- Separate frontend and backend concerns
- Use consistent data models
- Implement proper authentication
- Design scalable database schemas
- Use appropriate caching strategies

### API Development
- Follow RESTful principles
- Implement proper validation
- Use consistent error responses
- Document all endpoints
- Implement rate limiting

### Database
- Use migrations for schema changes
- Implement proper indexing
- Consider data relationships
- Handle transactions appropriately
- Implement backup strategies
`;
  }

  private getMobileTemplate(): string {
    return this.getDefaultTemplate() + `

## Mobile Application Guidelines

### Performance
- Optimize for mobile hardware
- Implement proper image handling
- Use efficient data structures
- Minimize memory usage
- Consider battery impact

### User Experience
- Follow platform design guidelines
- Implement proper navigation
- Handle different screen sizes
- Provide offline functionality
- Use appropriate gestures

### Platform Considerations
- Handle platform-specific features
- Test on multiple devices
- Consider app store requirements
- Implement proper permissions
- Use native APIs when needed
`;
  }
}